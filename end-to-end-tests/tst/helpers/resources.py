from resource_types import ResourceTypes
from resource_status import ResourceStatus

import re

class Resources:

    LOGICALID_WITH_HASH_PATTERN = "^(.+)([a-fA-F0-9]{10})$"

    def __init__(self):
        self.resources = dict()

    def created(self, logical_resource_id, resource_type):
        return self.add(logical_resource_id, resource_type.value, ResourceStatus.CREATE_COMPLETE.value)

    def updated(self, logical_resource_id):
        return self.set_status(self, logical_resource_id, ResourceStatus.UPDATE_COMPLETE.value)

    def add(self, logical_resource_id=None, resource_type=None, resource_status=None, stack_resource=None):
        if stack_resource is not None:
            # LogicalID of ApiGateway::Deployment resource gets suffixed with SHA of the Swagger URI.
            # This suffix changes on every run of the test. To keep tests simple, we will validate and strip
            # out this suffix here. Tests can continue to access and verify the resource using the LogicalId
            # specified in the template
            logical_id = self.clean_logicalid_if_necessary(
                logical_id_to_clean=stack_resource.get("LogicalResourceId"),
                resource_type=stack_resource.get("ResourceType"),
            )
            return self.add(
                logical_resource_id=logical_id,
                resource_type=stack_resource.get("ResourceType"),
                resource_status=stack_resource.get("ResourceStatus"),
            )
        else:
            new_resource = Resource(logical_resource_id, resource_type, resource_status)
            if logical_resource_id in self.resources.keys():
                raise ValueError("Resource already exists. LogicalID = {}".format(logical_resource_id))
            self.resources[logical_resource_id] = new_resource
            return self

    def set_status(self, logical_resource_id, new_status):
        resource = self.resources.get(logical_resource_id)

        if resource is None:
            raise ValueError("Resource with logical ID not found - {}".format(logical_resource_id))
        resource.status = new_status
        return self

    def remove(self, logical_resource_id):
        self.resources.remove(logical_resource_id)
        return self

    def from_list(self, resources_list):
        resources_from_list = Resources()
        for stack_resource in resources_list:
            resources_from_list.add(stack_resource=stack_resource)
        return resources_from_list

    # helper method for adding tests, call when needed
    def get_changed_resources(self, expected_resources):
        diff_resources = dict()
        for key in self.resources.keys():
            if key not in expected_resources.resources or not expected_resources.resources.get(
                key
            ) == self.resources.get(key):
                diff_resources[key] = self.resources.get(key)
            # remove the resource if its same in generated resources and expected resources
            expected_resources.resources.pop(key, None)

        if expected_resources.resources is not None:  # empty
            diff_resources.update(expected_resources.resources)

        return diff_resources

    def __eq__(self, other):
        if not isinstance(other, Resources):
            return False
        # checking if the keys are same
        if self.resources.keys() != other.resources.keys():
            return False
        for id, resource in self.resources.items():
            if not (resource == other.resources.get(id)):
                return False
        return True

    """
    Validates and Cleans up LogicalIDs generated by SAM translator.
    @param logical_id_to_clean
    @param resource_type
    @return
    """

    def clean_logicalid_if_necessary(self, logical_id_to_clean, resource_type):
        if (
            ResourceTypes.APIGW_DEPLOYMENT.value == resource_type
            or ResourceTypes.LAMBDA_VERSION.value == resource_type
            or ResourceTypes.LAMBDA_LAYER_VERSION.value == resource_type
        ):
            if not re.match(self.LOGICALID_WITH_HASH_PATTERN, logical_id_to_clean):
                raise ValueError(
                    "{} LogicalID of {} does not follow pattern. It should end with 10 hex characters generated by the SHA".format(
                        logical_id_to_clean, resource_type
                    )
                )
            return logical_id_to_clean[:-10]  # remove last 10 digits and return
        return logical_id_to_clean


class Resource:
    # We only care about the following properties when comparing for equality because rest are dynamically
    # generated by CloudFormation: LogicalResourceId, ResourceStatus, ResourceType
    logical_id = str()
    type = str()
    resource_status = None  # instance of ResourceStatus

    def __init__(self, id, type, resource_status):
        self.logical_id = id
        self.type = type
        self.resource_status = resource_status

    def __eq__(self, other):
        if not isinstance(other, Resource):
            return False
        return (
            self.logical_id == other.logical_id
            and self.type == other.type
            and self.resource_status == other.resource_status
        )
